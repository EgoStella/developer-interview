# Data Structure

## Table of Contents
* [배열과 링크드 리스트 비교](#배열과-링크드-리스트-비교)
* [배열 리스트와 링크드 리스트 비교](#배열-리스트와-링크드-리스트-비교)
* [해시 테이블](#해시-테이블)
* [Stack과 Queue](#stack과-queue)
* [Tree](#tree)
* [힙](#힙)
* [Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스](#binary-search-tree의-최악의-시간복잡도와-최악의-시간복잡도를-유발하는-케이스)
* [Graph 자료구조](#graph-자료구조)
* [Graph를 구현하는 두 가지 방법과 장점](#graph를-구현하는-두-가지-방법과-장점)

## 배열과 링크드 리스트 비교
### (1) 배열
* 순차적으로 데이터를 저장하는 자료구조로 `메모리 상에 연속적으로 할당한` 자료구조
* 배열은 순서를 알고 있다면 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`
### (2) 링크드 리스트 
* `따로 할당하고 이은` 자료구조, 자료의 주소값으로 서로 연결
* 링크드 리스트는 `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`

## 배열 리스트와 링크드 리스트 비교
### (1) 배열 리스트
* 내부적으로는 배열을 활용하기 때문에 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`
* 원하는 데이터에 무작위 접근 가능
* 리스트의 크기에는 제한이 있어 크기 재조정에는 많은 연산 필요
* 데이터의 추가/삭제에는 임시 배열을 생성하여 복제해 시간이 오래 걸림
* 캐시의 특성 때문에 빈번한 삽입 삭제가 나지 않는 경우라면 배열 리스트를 사용할 때 일반 적으로 성능이 더 좋음
### (2) 링크드 리스트 
* `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`
* 무작위 접근은 불가능, 순차 접근만 가능
* 리스트의 크기에 영향 없이 데이터 추가 가능
* 데이터 추가에는 새로운 노드를 생성해 연결하므로 추가/삭제 연산이 빠름

## 해시 테이블
* Key와 Value로 데이터 저장
* 배열과 리스트의 장점을 합친 자료구조로 `key 값`을 통해 해시 주소를 알아내어 평균적으로 `탐색에 있어 O(1)`을 보장하는 자료구조
* 해시 충돌이 발생할 경우, 같은 해시값에 대해 데이터들을 조회해 원하는 값을 찾기 때문에 `O(N)` 가능
* `해시 충돌`(서로 다른 key가 같은 hash로 변경되는 문제)이 나는 경우 그 다음 비어 있는 공간에 삽입하는 방식인 `선형 조사법` 또는 해시 주소로 관리되는 데이터를 연결 리스트로 관리하는 방식인 `체이닝 기법`을 통해서 해결

## Stack과 Queue
### (1) Stack
* LIFO 방식으로 삽입되고 제거되는 최근성에 포커싱된 자료구조
* Array로 구현하는 것이 좋음
### (2) Queue
* FIFO 방식으로 삽입되고 제거되는 순차성에 포커싱된 자료구조
* Linked List로 구현하는 것이 좋음

## Tree
* 트리는 `사이클을 가지지 않는 그래프`로 부모 자식 관계를 갖는 노드들의 집합으로 `계층적` 구조를 갖는 자료구조
* `이진 트리(Binary Tree)`: 최대 2개의 자식 노드들만 가질 수 있는 트리
* `포화 이진 트리(Full Binary Tree)`: 각 레벨에 노드가 꽉 차있는 트리
* `완전 이진 트리(Complete Binary Tree)`: 높이가 K인 트리에서 레벨 1~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
* `이진 탐색 트리(Binary Search Tree)`: 탐색을 위해 만들어진 자료구조로 `부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작은 구조`

## 힙
* 힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조인데 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 최소값 또는 최대값을 쉽게 뽑아내기 위한 자료구조
* `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰/작은 완전 이진 트리`로 힙은 자식 노드에도 구분 조건이 필요한 이진 탐색 트리보다 느슨한 정렬 상태를 유지

## Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스
* 밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
* 최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
  * `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
  * `레드 블랙 트리`: 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음

## Graph 자료구조
* 정점과 간선으로 이루어진 자료구조

## Graph를 구현하는 두 가지 방법과 장단점
* `인접 행렬`을 사용하는 방법: 인접 행렬의 해당하는 위치의 value 값을 통해서 vertex 간의 연결 관계를 `O(1)`으로 파악하는 방법으로 `정점과 엣지가 많을 경우 사용`(2차원 배열), 구현 간편, 공간 낭비
* `인접 리스트`를 사용하는 방법: 각 vertex의 adjacent list를 통해서 연결 관계를 `O(정점에 연결된 노드의 수)`로 파악하는 방법으로 `정점과 엣지가 적을 경우 사용`, 공간 낭비 적음, 탐색 시간이 느림, 구현 어려움