# Data Structure

## Table of Contents
* [배열과 리스트 비교](#배열과-리스트-비교)
* [배열과 링크드 리스트 비교](#배열과-링크드-리스트-비교)
* [배열 리스트와 링크드 리스트 비교](#배열-리스트와-링크드-리스트-비교)
* [해시 테이블](#해시-테이블)
* [Stack과 Queue](#stack과-queue)
* [Tree](#tree)
* [힙](#힙)
* [Binary Search Tree](#binary-search-tree)
* [Graph 자료구조](#graph-자료구조)
* [Graph를 구현하는 두 가지 방법과 장점](#graph를-구현하는-두-가지-방법과-장점)

## 배열과 리스트 비교
### (1) 배열
* 순차적으로 데이터를 저장하는 자료구조로 `메모리 상에 연속적으로 할당한` 자료구조
* 조회 성능이 좋고, 삽입/삭제 성능은 나쁨
* 선언 시 지정한 크기 변경 불가
### (2) 리스트
* 메모리가 연속적인 공간에 있지 않고 다음 노드를 가리키는 주소값을 가져 주소를 통해 접근
* 조회 성능이 나쁘고, 삽입/삭제 성능은 좋음
* 크기가 고정적이지 않음

## 배열과 링크드 리스트 비교
### (1) 배열
* 순차적으로 데이터를 저장하는 자료구조로 `메모리 상에 연속적으로 할당한` 자료구조
* 배열은 순서를 알고 있다면 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`
### (2) 링크드 리스트 
* `따로 할당하고 이은` 자료구조, 자료의 주소값으로 서로 연결
* 링크드 리스트는 `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`

## 배열 리스트와 링크드 리스트 비교
### (1) 배열 리스트
* 내부적으로는 배열을 활용하기 때문에 `탐색에서 O(1)`, `삽입 삭제에서 O(N)`
* 원하는 데이터에 무작위 접근 가능
* 리스트의 크기에는 제한이 있어 크기 재조정에는 많은 연산 필요
* 데이터의 추가/삭제에는 임시 배열을 생성하여 복제해 시간이 오래 걸림
* 캐시의 특성 때문에 빈번한 삽입 삭제가 나지 않는 경우라면 배열 리스트를 사용할 때 일반적으로 성능이 더 좋음
  * Cache locality: 운영체제에선 물리적으로 근접한 위치의 데이터가 주로 활용되기 때문에 미리 캐쉬에 넣어둠으로써 CPU의 성능을 향상시킨다. 배열은 물리적으로 연속된 공간에 데이터를 저장하기 때문에 이러한 locality를 잘 활용할 수 있다.
  * Cache hit: 지역성을 활용하기 위해 캐쉬에 저장해놓은 메모리에 CPU가 참조하고자 하는 메모리가 있다면 cahce hit, 캐쉬 적중이라고 한다. 반대의 개념은 cache miss.
  * Spatial locality: Cache locality에서 설명한 지역성은 시간 지역성(Temporal locality)과 공간 지역성(Spatial Locality)으로 나뉜다. 시간 지역성(Temporal locality)이란 가장 최근에 읽어온 data는 다시 읽어올 때도 빠르게 access할 수 있다는 뜻이다. for나 while 같은 반복문에 사용하는 조건 변수처럼 한번 참조된 데이터는 잠시 후에 또 참조될 가능성이 높다. 공간 지역성이란 A[0], A[1]과 같은 데이터 배열에 연속으로 접근할 때 참조된 데이터 근처에 있는 데이터가 잠시 후에 사용될 가능성이 높다는 것이다. (100번지 명령어 이후에 104번지 명령어 수행)

### (2) 링크드 리스트 
* `탐색에서 O(N)` 순서를 알고 있다면 `삽입 삭제에서 O(1)`
* 무작위 접근은 불가능, 순차 접근만 가능
* 리스트의 크기에 영향 없이 데이터 추가 가능
* 데이터 추가에는 새로운 노드를 생성해 연결하므로 추가/삭제 연산이 빠름

## 해시 테이블
* 데이터를 효율적으로 관리하기 위해, 임의의 길이 데이터를 고정된 길이의 데이터로 매핑하는 것
* 해시 함수를 구현하여 데이터 값을 해시 값으로 매핑
* Key와 Value로 데이터를 저장하는 자료구조
* 데이터가 많아지면 다른 데이터가 같은 해시 값으로 충돌이남
  * 그럼에도 적은 자원으로 많은 데이터를 효율적으로 관리하기 위해 하드디스크나, 클라우드에 존재하는 무한한 데이터들을 유한한 개수의 해시값으로 매핑하면 작은 메모리로도 프로세스 관리가 가능해져서 사용함
* 배열과 리스트의 장점을 합친 자료구조로 `key 값`을 통해 해시 주소를 알아내어 평균적으로 `탐색에 있어 O(1)`을 보장하는 자료구조
  * 이진탐색트리는 `O(logN)`
* 해시 충돌이 발생할 경우, 같은 해시값에 대해 데이터들을 조회해 원하는 값을 찾기 때문에 `O(N)` 가능
* `해시 충돌`(서로 다른 key가 같은 hash로 변경되는 문제)이 나는 경우 그 다음 비어 있는 공간에 삽입하는 방식인 `선형 조사법` 또는 해시 주소로 관리되는 데이터를 연결 리스트로 관리하는 방식인 `체이닝 기법`을 통해서 해결

## Stack과 Queue
### (1) Stack
* LIFO 방식으로 삽입되고 제거되는 최근성에 포커싱된 자료구조
* Array로 구현하는 것이 좋음
### (2) Queue
* FIFO 방식으로 삽입되고 제거되는 순차성에 포커싱된 자료구조
* Linked List로 구현하는 것이 좋음

## Tree
* 트리는 `사이클을 가지지 않는 그래프`로 부모 자식 관계를 갖는 노드들의 집합으로 `계층적` 구조를 갖는 자료구조
* `이진 트리(Binary Tree)`: 최대 2개의 자식 노드들만 가질 수 있는 트리
* `포화 이진 트리(Full Binary Tree)`: 각 레벨에 노드가 꽉 차있는 트리
* `완전 이진 트리(Complete Binary Tree)`: 높이가 K인 트리에서 레벨 1~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
* `이진 탐색 트리(Binary Search Tree)`: 탐색을 위해 만들어진 자료구조로 `부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작은 구조`

## 힙
* 힙은 `완전 이진 트리`의 일종으로 `우선 순위 큐`를 구현하기 위해 만들어진 자료구조인데 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 `최소값 또는 최대값`을 쉽게 뽑아내기 위한 자료구조
* `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰/작은 완전 이진 트리`로 힙은 자식 노드에도 구분 조건이 필요한 이진 탐색 트리보다 느슨한 정렬 상태를 유지
* 힙 트리는 중복된 값 허용 (이진 탐색 트리는 중복값 허용X)
* 최대 힙(max heap)
  * `부모 노드의 키 값이 자식 노드의 키 값보다 크거나 같은` 완전 이진 트리
  * 부모가 최대값
* 최소 힙(min heap)
  * `부모 노드의 키 값이 자식 노드의 키 값보다 작거나 같은` 완전 이진 트리
  * 부모가 최소값
* 힙의 삽입
  * `O(logn)`
  * 힙에 새로운 요소가 들어오면, 일단 새로운 노드를 힙의 마지막 노드에 삽입
  * 새로운 노드를 부모 노드들과 교환
* 힙의 삭제
  * `O(logn)`
  * 최대 힙에서 최대값은 루트 노드이므로 루트 노드가 삭제됨 (최대 힙에서 삭제 연산은 최대값 요소를 삭제하는 것)
  * 삭제된 루트 노드에는 힙의 마지막 노드를 가져옴
  * 힙을 재구성

## Binary Search Tree
* 부모보다 작은 값은 왼쪽 자식, 큰 값은 오른쪽 자식. 검색시 내려가면서 해당 노드보다 찾는값이 더 작으면 왼쪽에서 찾고, 찾는값이 더 크면 오른쪽에서 찾는다.
* 노드의 `왼쪽 서브트리에는 그 노드의 값보다 작은 값들`을 지닌 노드들로 이루어져 있다. 노드의 `오른쪽 서브트리에는 그 노드의 값보다 큰 값들`을 지닌 노드들로 이루어져 있다.
* 이진탐색 + 연결리스트
  * 이진탐색 : `탐색에 소요되는 시간복잡도는 O(logN)`, but `삽입,삭제가 불가능`
  * 연결리스트 : `삽입, 삭제의 시간복잡도는 O(1)`, but `탐색하는 시간복잡도가 O(N)`
* 밸런싱이 된 BST는 `O(logN)`이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
  * 삽입, 검색, 삭제 시간복잡도는 `트리의 Depth에 비례`
* 최악의 경우를 방지하는 방법: 자가 균형 트리(Balanced Tree)
  * `AVL 트리`: 왼쪽과 오른쪽 자식의 높이 차이가 1이하일 것을 요구, 삭제/추가 시에 재정렬을 통해 높이를 일정하게 유지, 레드 블랙 트리보다 엄격
  * `레드 블랙 트리`: 모든 노드가 빨강 또는 검정의 색을 갖는 트리로 최장 경로의 거리는 최단 경로의 거리의 두 배 이상이 될 수 없음, 삭제/추가 시에 재정렬과 색깔 재배치를 통해 규칙을 유지
* 삭제
  * 자식이 없는 leaf 노드일 때 : 그냥 삭제
  * 자식이 1개인 노드일 때 : 지워진 노드에 자식노드로 대체하고 지워진 노드의 부모노드와 연결
  * 자식이 2개인 노드일 때 : 오른쪽 서브트리에서 가장 작은 값 or 왼쪽 서브트리에서 가장 큰 값으로 대체

## Graph 자료구조
* 정점과 간선으로 이루어진 자료구조

## Graph를 구현하는 두 가지 방법과 장단점
* `인접 행렬`을 사용하는 방법: 2차원 배열을 사용해 정점들의 연결관계를 파악하는 방법으로, 시간 복잡도 `O(1)`로 연결 관계를 파악할 수 있음, `정점과 엣지가 많을 경우 사용`, 구현 간편, 공간 낭비
* `인접 리스트`를 사용하는 방법: 각 정점의 adjacent list를 통해서 연결 관계를 파악하는 방법으로, 정점들의 관계를 `O(정점에 연결된 노드의 수)`로 파악하는 방법, `정점과 엣지가 적을 경우 사용`, 공간 낭비 적음, 탐색 시간이 느림, 구현 어려움