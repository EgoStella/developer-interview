### Datastructure
* 배열과 링크드 리스트 비교
  * 배열은 순차적으로 데이터를 저장하는 자료구조로 메모리 상에 연속적으로 할당한 자료구조이고 링크드 리스트는 따로 할당하고 이은 자료구조
  * 배열은 순서를 알고 있다면 탐색에서 O(1) 삽입 삭제에서 O(N)
  * 링크드 리스트는 탐색에서 O(N) 순서를 알고 있다면 삽입 삭제에서 O(1)
* 배열 리스트와 링크드 리스트 비교
  * 배열 리스트는 내부적으로는 배열을 활용하기 때문에 탐색에서 O(1) 삽입 삭제에서 O(N)
  * 링크드 리스트는 탐색에서 O(N) 순서를 알고 있다면 삽입 삭제에서 O(1)
  * 캐시의 특성 때문에 빈번한 삽입 삭제가 나지 않는 경우라면 배열 리스트를 사용할 때 일반 적으로 성능이 더 좋음
* 해쉬테이블
  * 배열과 리스트의 장점을 합친 자료구조로 key 값을 통해 해시 주소를 알아내어 탐색에 있어 O(1)을 보장하는 자료구조
  * `해시 충돌`이 나는 경우 그 다음 비어 있는 공간에 삽입하는 방식인 선형 조사법 또는 해시 주소로 관리되는 데이터를 연결 리스트로 관리하는 방식인 체이닝 기법을 통해서 해결
* Stack과 Queue
  * Stack은 LIFO 방식으로 삽입되고 제거되는 최근성에 포커싱된 자료구조이고 Queue는 FIFO 방식으로 삽입되고 제거되는 순차성에 포커싱된 자료구조
* Tree, Binary Tree, Full Binary Tree, Complete Binary Tree, Binary Search Tree 
  * 트리는 그래프의 스페셜 케이스로 `사이클을 가지지 않는 그래프`로 부모 자식 관계를 갖는 노드들의 집합으로 계층적 구조를 갖는 자료구조
  * `이진 트리`는 최대 2개의 자식 노드들만 가질 수 있는 트리
  * `포화 이진 트리`는 각 레벨에 노드가 꽉 차있는 트리
  * `완전 이진 트리`는 높이가 K인 트리에서 레벨 1~ 레벨 K-1까지 모두 채워져 있고 마지막 레벨에서는 왼쪽부터 순서대로 채워져 있는 트리
  * `이진 탐색 트리`는 탐색을 위해 만들어진 자료구조로 `부모 노드의 키 값이 왼쪽 자식 노드의 키값보다 크고 오른쪽 자식 노드의 키값보다 작거나 같은 구조`
* 힙
  * 힙은 완전 이진 트리의 일종으로 우선 순위 큐를 구현하기 위해 만들어진 자료구조인데 이진 탐색 트리가 전체 노드를 탐색하기 위한 자료구조라면 힙은 최소값 또는 최대값을 쉽게 뽑아내기 위한 자료구조
  * `부모 노드의 키 값이 자식 노드의 키 값보다 항상 큰 완전 이진 트리`로 힙은 자식 노드에도 구분 조건이 필요한 이진 탐색 트리보다 느슨한 정렬 상태를 유지
* Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스
  * 밸런싱이 된 BST는 O(logN)이지만 밸런싱이 되지 않지 않고 `한쪽으로만 삽입된 경우 O(N)`
* Graph 자료구조
  *
* Graph를 구현하는 두 가지 방법과 장점
  * 인접 행렬을 사용하는 방법: 인접 행렬의 해당하는 위치의 value 값을 통해서 vertex 간의 연결 관계를 `O(1`)으로 파악하는 방법으로 `정점과 엣지가 많을 경우 사용`
  * 인접 리스트를 사용하는 방법: 각 vertex의 adjacent list를 통해서 연결 관계를 `O(정점에 연결된 노드의 수)`로 파악하는 방법으로 `정점과 엣지가 적을 경우 사용`