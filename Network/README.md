### Network
* TCP와 UDP의 차이
  * TCP는 `신뢰성을 보장하는 연결형 프로토콜`로 `흐름제어, 혼잡제어`를 제공
  * UDP는 `신뢰성을 보장하지 않는 비연결형 프로토콜`로 흐름제어, 혼잡제어를 제공하지 않음
* TCP 흐름제어: 수신자와 송신자의 메시지 처리속도 차이를 해결하기 위한 방법
  - 수신자와 송신자 세그먼트 간의 TCP Header에 `remain window data`를 통해 남은 버퍼를 알고 흐름을 파악할 수 있음
  * `Stop and Wait`: 전송한 패킷의 ACK을 수신하면 다음 패킷 전송
  * `Sliding Window`: N개의 패킷을 ACK의 확인 없이 전송, 데이터의 흐름을 동적으로 조절
    * `Go Back N`: Cumulative ACK(마지막으로 수신 성공한 패킷의 ACK을 계속 전송), 문제가 된 패킷부터 모두 재전송
    * `Selective Repeat`: Individual ACK(수신 성공한 패킷의 개별 ACK 전송), 문제가 된 패킷만 재전송
* TCP 혼잡제어: 송신자와 네트워크(라우터)의 데이터 처리 속도 차이를 해결하기 위한 방법
  - 패킷 loss 시의 확인되는 `timeout이나 3개의 duplicate ACK`을 통해서 파악 가능
  * `TCP Tahoe`
    * 3개의 duplicate ACK, Timeout 발생 -> Slow Start(CWND가 1부터 지수적으로, 2배씩 증가), Congestion Avoidance(CWND가 1씩 증가)
  * `TCP Reno`
    * Congestion Avoidance 상황에서 3개의 duplicate ACK 발생 -> CWND를 1/2배로 감소하고 선형적 증가
     (TCP Tahoe는 Slow Start로 진입)
    * Congestion Avoidance 상황에서 Timeout 발생 -> Slow Start (CWND = 1)
* TCP 3-way handshake가 언제 일어나고 어떤 과정인지
  * 서버와 클라이언트가 TCP `연결을 성립할 때` 사용
  * Client -> Server: `SYN 전송`
  * Server -> Client: `SYN 전송 + ACK 전송`
  * Client -> Server: `ACK 전송`
  * TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결을 성립할 때는 서버가 준비가 다 된 상태인 대기 상태에서 시작하여 3-way로 가능
  * TCP는 양방향 프로토콜이므로 클라이언트와 서버가 각각 서로에게 패킷을 전송할 수 있다는 것을 확인해야 되므로 3 way 사용
* TCP 4-way handshake가 언제 일어나고 어떤 과정인지
  * 서버와 클라이언트가 TCP `연결을 종료할 때` 사용
  * Client -> Server : `FIN 전송`
  * Server -> Client : `ACK 전송`
  * Server -> Client : `FIN 전송`
  * Client -> Server : `ACK 전송`
  * 서버의 지연된 패킷을 수신하기 위해 클라이언트에 Timeout 존재
  * TCP는 양방향성 연결이기 때문에 발생하는 매커니즘으로 연결 해제할 때는 한 쪽이 준비가 되지 않은 상태이기 때문에 연결 해제 대기 상태로 만들기 위해서 4-way로 해야 가능
  * 클라이언트가 일방적으로 끊으면 서버는 '연결은 되어 있으나 요청이 없는 상태'로 오해할 수 있어 4 way 사용
  * 클라이언트는 데이터 전송을 끝냈다고 하더라도 서버는 전송할 것이 남아있을 수 있어 4 way 사용
* OSI 7계층와 각 계층 역할
  * 정의: 네트워크의 통신 과정을 7단계로 나눈 것
  * 사용 이유: 이해하기 쉬움, 문제 발생시 해당 단계의 장비와 SW만 수정하면 됨
  * Application - Application(7), Presentation(6), Session(5) 계층으로 분리
  * Application(7, Data): 사용자에게 `실제 애플리케이션 서비스`를 제공하는 계층 / HTTP
  * Presentation(6, Data): 애플리케이션의 `데이터 형태와 구조를 변환(번역, 암호화, 압축)`시키는 계층
  * Session(5, Data): 애플리케이션 간의 `TCP/IP 세션을 구축하고 관리하며 종료`시키는 계층
  * Transport(4, Segment): 통신 `양단 간의 신뢰성 있는 통신`을 보장하는 계층 / TCP or UDP
  * Network(3, Packet or Datagram): 목적지까지의 경로를 선택하고 `경로에 따라 패킷을 전달(라우팅)`해주는 계층 / IP
  * Link(2, Frame): 인접한 `피어 간의 신뢰성 있는 통신`을 보장하는 계층 / MAC
  * Physical(1, Bit): 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송
* HTTP와 HTTPS의 차이
  * HTTP는 웹 브라우저와 웹 서버가 통신하기 위한 프로토콜이고 HTTPS는 HTTP Secure의 약자로 HTTP에 SSL/TLS 기반의 Secure Socket을 활용한 프로토콜
  * HTTP는 평문 통신이기 때문에 `도청`이 가능하고 `변조`가 가능하며 통신 상대를 특정하지 않기 때문에 `위장`이 가능
  * HTTPS는 웹 브라우저와 웹 서버가 각각 키를 갖고 있고 `그 키를 통해 암호화/복호화하여 HTTP 통신`하므로 클라이언트와 서버만이 데이터를 열람 가능
* HTTP 상태코드  
  * 2xx: 성공
  * 3xx: 리다이렉션
  * 4xx: 클라이언트 에러
  * 5xx: 서버 에러
* 공개키
  * 비공개키와 공개키 2개의 키로 쌍으로 암호화/복호화하는 기법으로 비공개키는 자신만이 소유하고 공개키는 타인에게 제공하는 방식으로 작동
* SSL/TLS 동작방식
  * 
* 쿠키와 세션이 무엇이고 차이가 뭔지
  * 쿠키는 `클라이언트 로컬`에 저장되는 키와 값이 들어있는 작은 텍스트 데이터 파일
  * 세션은 일정 시간동안 같은 브라우저로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 객체로 `서버`에 저장하는 기술
  * 쿠키는 클라이언트 로컬에 작은 파일로 저장하지만 세션은 서버에 제한 없는 파일로 저장하고 `sessionid`를 통해 데이터를 구분하여 처리하여 보안이 좋음
* 웹 서버와 웹 애플리케이션 서버의 차이점
  * 웹 서버: Http 프로토콜을 기반으로, 클라이언트의 요청을 서비스하는 기능을 담당하는 서버로 정적 컨텐츠만 처리하는 고성능 서버
  * 웹 애플리케이션 서버: 보통 웹서버 뒤에서 DB 조회 및 다양한 로직 처리 요구시 동적인 컨텐츠를 처리하는 서버
* 웹 브라우저에 URL을 입력했을 때의 수행 과정
  * 사용자의 PC는 `DHCP 서버`에서 사용자 `자신의 IP 주소`, `가장 가까운 라우터의 IP 주소`, `가장 가까운 DNS 서버의 IP 주소`를 받는다.
  * `ARP`를 이용하여 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 받는다.
  * TCP Socket을 통해 웹 서버와 `3 way hand shaking`을 하여 연결한다.
  * `HTTP Request`가 TCP Socket을 통해 보내지고, 응답으로 웹페이지의 정보가 사용자의 PC에 전달
* 기타 네트워크 프로토콜과 기본 네트워크 주소들
  * DHCP: 호스트의 IP 주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜
  * DNS: IP 주소와 도메인의 매핑정보를 관리하는 프로토콜
  * ARP: IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
  * IP 주소: 컴퓨터 마다 부여된 고유의 주소
  * MAC 주소: NIC 카드 마다 부여된 네트워크 장비 고유의 주소
* HTTP GET 방식과 POST 방식의 차이
  * `GET은 정보를 조회하기 위한 메소드`이고 `POST는 서버로 데이터를 전송하기 위해 설계된 메소드`
  * 둘다 데이터를 서버에 전달할 수 있다는 것이 공통점이지만 GET은 URL의 파라미터로 이름과 데이터가 쌍으로 명시되어 전달되고, POST는 HTTP Request Message의 Body 부분에 데이터가 담겨있음
  * GET은 `URL의 길이는 제한적이기` 때문에 많은 양의 데이터를 전송할 수 없지만 POST는 `HTTP Request Message의 Body 부분에` 데이터가 담겨있어 제한이 없음
* HTTP POST 방식과 PUT 방식의 차이
  * 일반적으로 POST는 생성, PUT은 수정이지만 PUT으로도 생성이 가능
  * POST와 가장 큰차이는 PUT 메서드는 자원의 식별자를 이미 알고있는 상태로 POST는 request message로 포함된 엔티티를 이용해 새로운 자원을 생성해 내는 것이고, PUT은 request message와 함께 넘어온 식별자의 자원을 만드는 것
* 웹 캐시
  * 대부분의 브라우저에서는 `HTTP 헤더`에 캐시 구현이 포함되어 있어서 웹 캐시를 구현
  * 응답헤더의 `Last-Modified`, Etag, Expires, Cache-Control 항목 등과 같은 여러 부분의 여러 개의 태그를 통해서 캐싱
  * Cache-Control: HTTP 헤더를 통해 캐싱 정책을 정의할 수 있다. `no-cache` vs `no-store`
  * 브라우저는 최초 응답 시 받은 Last-Modified 값을 If-Modified-Since라는 헤더에 포함 시켜 페이지를 요청 -> 서버는 요청 파일의 수정 시간을 If-Modified-Since값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Last-Modified 값을 갱신
  * 브라우저는 최초 응답 시 받은 Etag값을 If-None-Match라는 헤더에 포함 시켜 페이지를 요청 -> 서버는 요청 파일의 Etag 값을 If-None-Match 값과 비교하여 동일하다면 304 Not Modified로 응답하고 다르다면 200 OK와 함께 새로운 Etag 값을 응답 헤더에 전송 -> 브라우저는 응답 코드가 304인 경우 캐쉬에서 페이지를 로드하고 200이라면 새로 다운받은후 Etag값을 갱신
  * 브라우저는 최초 응답 시 받은 Expires 시간을 비교하여 기간 내라면 서버를 거치지 않고 바로 캐쉬에서 페이지를 로드
* CDN과 사용 시의 이점
  * CDN은 Contents Delivery Network의 약자로 지리적, `물리적으로 떨어져 있는 사용자에게 웹 페이지 콘텐츠 로드 지연을 최소화하는, 촘촘히 분산된 서버로 이루어진 플랫폼 기술`
  * 웹 브라우저를 실행하는 디바이스인 사용자 에이전트는 HTML, 이미지, CSS, JavaScript 파일을 렌더링하는데 필요한 콘텐츠를 요청하고 요청된 서버에 의해 `콘텐츠에 대한 각 요청이 발생하면 최적으로 배치된 CDN 서버에 엔드유저가 매핑`되고, 해당 서버는 요청된 파일의 캐싱된(사전 저장된) 버전으로 응답하여 CDN 서버에게서 데이터를 전송받도록함
* 로드 밸런싱
  * 로드 밸런서를 클라이언트와 서버 사이에 두고, 부하가 일어나지 않도록 여러 서버에 분산하는 방식
  * 로드 밸런서는 물리 장비를 이중화해서 구현하거나 nginx와 같은 웹서버를 이용하여 구현
* CIDR
  * 클래스 없는 도메인 간 라우팅 기법으로 최신의 IP 주소 할당 방법으로 정적이였던 클래스 방식에 비해 IP 주소의 영역을 여러 네트워크 영역으로 나눌 수 있기 때문에 기존방식에 비해 유연
* RESTful API
  * `REST`는 `HTTP, WWW에서 웹에 존재하는 모든 자원에 고유한 URI를 부여해 활용하는 것`으로, 자원을 정의하고 자원에 대한 주소를 지정하는 방법론
  * `RESTful API`는 `REST 기반의 규칙들을 지켜서 설계된 API`
  * 기본 설계 원칙1. `/`를 계층관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
  * 기본 설계 원칙2. 자원에 대한 정보는 명사로 표현하고 자원에 대한 `행위는 HTTP 메소드`로 표현
  * 기본 설계 원칙3. 소문자와 `-`를 사용
  * 기본 설계 원칙4. 브라우저는 form-data 형식의 submit 으로 보내고 서버에서는 json 형태로 보내는 식의 분리보다는 둘 다 form-data 형식으로 보내든 하나로 통일
* RESTful API 장단점
  * HTTP를 사용하므로 웹 인프라를 그대로 이용할 수 있고 MSA에 적합하여 재사용에서 이점이 존재
  * HTTP를 사용하므로 HTTP 통신 모델에 제약적
* url 입력부터 응답이 오는 과정
  *
* 웹 브라우저에 http 응답이 랜더링되는 과정
  *
