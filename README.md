# Backend Developer Interview Questions
백앤드 개발자 인터뷰 질문 모음과 팁 & 답변

### Table of Content
- [Basics](#basics)
- [OS](#os)
- [Network](#network)
- [Database](#database)
- [Datastructure](#datastructure)
- [Algorithm](#algorithm)
- [Etc](#etc)
- [Optional:Python](#python)
- [Optional:Django](#django)
- [Optional:Java](#java)
- [Optional:Spring](#spring)

### Basics
* 자기소개
  * 이력 중심으로 간단하게 설명하되 신입이라면 성장 욕구를 간단히 어필하는 문구를 넣어도 좋음
* 가장 성공적이었던 프로젝트가 무엇이고 왜 성공적이라고 생각하는지
  * 현재 지원한 공고에 맞는 프로젝트를 성공적인 프로젝트로 지정하여 말하는 것이 유리
* 우리 회사 서비스 중에 사용해본 것
  * 지원한 공고에 맞는 회사 기술 블로그를 분석하고 그와 연관된 서비스를 말하는 것이 유리 
* 지금까지 했던 프로젝트 중 하면서 어려웠던 부분과 극복한 방법
  * 기존에 미리 준비하고 답변하는 것이 유리하며 지원한 회사의 직무에 연관되어 있으면 더 좋음
* 최근 관심 있게 보고 있는 기술
  * 지원한 회사의 직무에 연관되어 있으면 유리
* 이전 직장에서 아쉬웠던 부분과 왜 이직하려는지
  * 이직하고자 하는 회사만의 분명한 장점을 생각해놓고 답변하는 것이 좋음

  
### OS
* 프로세스와 스레드의 차이
  * 프로세스는 프로그램의 실행 상태로 운영체제로부터 자원을 할당받아 실행하고 스레드는 경량 프로세스로서 프로세스 안에서 프로세스로부터 자원을 받아 실행
  * 프로세스는 `코드/데이터/스택/힙` 메모리 영역을 기반하지만, 스레드는 프로세스의 코드/데이터/힙 메모리 영역을 공유하고 `개별적인 스택`을 기반으로 함
* deadlock과 deadlock 해결 방법
  * 데드락이란 멀티 프로세스/스레딩 환경에서 잘못된 자원 관리 때문에 프로세스/스레드가 `Block`되어 다른 프로세스/스레드의 작업이 끝나기만을 기다리는 현상
  * lock을 잡는 순서를 모든 프로세스가 동일하게 코딩하는 방법 or `trylock`을 활용하여 lock을 선점한 프로세스/스레드가 없을 때만 락을 얻으려고 시도하는 방법을 통해 데드락을 해결
* 뮤텍스와 세마포어의 차이
  * 뮤텍스는 스레드 기반으로 공유 자원의 활용을 제어하는 매커니즘이고 세마포어는 프로세스 기반으로 공유 자원의 활용을 제어하는 매커니즘
* 가상메모리와 가상메모리 사용 시의 장점
  * 프로그램에 실제 메모리 주소가 아닌 가상의 메모리 주소를 주는 방식으로 프로그램 별로 사용 중인 메모리보다 큰 메모리를 사용하는 듯한 환상을 주는 기법
  * 실제 프로그램 전체를 적재하여 사용하지 않기 때문에 메모리 제약을 극복
  * 메모리의 실제 주소를 사용하지 않으므로 보안 상의 장점이 존재
* 문맥 교환
  * 하나의 프로세스가 CPU를 사용 중인 상태에서 다른 프로세스가 CPU를 사용하도록 하기 위해, 이전의 프로세스의 상태(문맥)를 보관하고 새로운 프로세스의 상태를 적재하는 작업
 


### Network
* TCP와 UDP의 차이
  * TCP는 `신뢰성을 보장하는 연결형 프로토콜`로 `흐름제어, 혼잡제어, 오류제어`를 제공
  * UDP는 `신뢰성을 보장하지 않는 비연결형 프로토콜`로 흐름제어, 혼잡제어, 오류제어를 제공하지 않음 
* OSI 7계층와 각 계층 역할
  * Application - Application(7), Presentation(6), Session(5) 계층으로 분리
  * Application(7): 사용자에게 `실제 애플리케이션 서비스`를 제공하는 계층 / HTTP
  * Presentation(6): 애플리케이션의 `데이터 형태와 구조를 변환`시키는 계층
  * Session(5): 애플리케이션 간의 `세션을 구축하고 관리하며 종료`시키는 계층
  * Transport(4): 통신 `양단 간의 신뢰성 있는 통신`을 보장하는 계층 / TCP와 UDP
  * Network(3): 목적지까지의 경로를 선택하고 `경로에 따라 패킷을 전달`해주는 계층 / IP
  * Link(2): 인접한 `피어 간의 신뢰성 있는 통신`을 보장하는 계층 / MAC
  * Physical(1): 전기적, 기계적, 기능적인 특성을 이용해서 통신 케이블로 데이터를 전송
* HTTP와 HTTPS의 차이
  * HTTP는 웹 브라우저와 웹 서버가 통신하기 위한 프로토콜이고 HTTPS는 HTTP에 SSL/TLS 기반의 Secure Socket을 활용한 프로토콜
  * HTTPS는 웹 브라우저와 웹 서버가 각각 키를 갖고 있고 그 키를 통해 암호화/복호화하여 HTTP 통신하므로 클라이언트와 서버만이 데이터를 열람 가능
* 쿠키와 세션이 무엇이고 차이가 뭔지
  * 쿠키는 `클라이언트 로컬`에 저장되는 키와 값이 들어있는 작은 데이터 파일
  * 세션은 일정 시간동안 같은 브라우저로 부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 `서버`에 저장하는 기술
  * 쿠키는 클라이언트 로컬에 파일로 저장하지만 세션은 서버에 저장하고 세션은 `sessionid`를 통해 데이터를 구분하여 처리하여 보안이 좋음
* TCP 3-way handshake가 언제 일어나고 어떤 과정인지
  * 서버와 클라이언트가 TCP 연결을 성립할 때 사용
  * Client -> Server : SYN 전송
  * Server -> Client : SYN 전송 + ACK 전송
  * Client -> Server : ACK 전송
* TCP 4-way handshake가 언제 일어나고 어떤 과정인지
  * 서버와 클라이언트가 TCP 연결을 종료할 때 사용
  * Client -> Server : FIN 전송
  * Server -> Client : ACK 전송
  * Server -> Client : FIN 전송
  * Client -> Server : ACK 전송
* 웹 브라우저에 www.google.com을 입력했을 때의 수행 과정
  * 사용자의 PC는 `DHCP 서버`에서 사용자 `자신의 IP 주소`, `가장 가까운 라우터의 IP 주소`, `가장 가까운 DNS 서버의 IP 주소`를 받는다.
  * `ARP`를 이용하여 IP 주소를 기반으로 가장 가까운 라우터의 MAC 주소를 받는다.
  * TCP Socket을 통해 웹 서버와 `3 way hand shaking`을 하여 연결한다.
  * `HTTP Request`가 TCP Socket을 통해 보내지고, 응답으로 웹페이지의 정보가 사용자의 PC에 전달
* 네트워크 프로토콜과 기본 네트워크 주소들
  * DHCP: 호스트의 IP 주소 및 TCP/IP 설정을 클라이언트에 자동으로 제공하는 프로토콜
  * DNS: IP 주소와 도메인의 매핑정보를 관리하는 프로토콜
  * ARP: IP 주소를 물리적 네트워크 주소로 대응시키기 위해 사용되는 프로토콜
  * IP 주소: 컴퓨터 마다 부여된 고유의 주소
  * MAC 주소: NIC 카드 마다 부여된 네트워크 장비 고유의 주소


### Database
* 스키마와 테이블(릴레이션)의 차이
  * 스키마는 테이블(릴레이션)의 이름과 속성들의 나열로 테이블에서의 첫 행인 헤더이고 테이블은 행과 열로 구성된 테이블을 의미
* Index를 사용하는 이유와 장점 및 단점
  * 인덱스는 데이터베이스의 `검색 속도`를 위해 사용하는 추가적인 자료구조로 테이블 내의 칼럼들로 정의
  * 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음
* 트랜잭션
  * 데이터베이스의 상태를 변화시킬 때 한번에 수행되어야하는 하나의 `원자적인` 작업의 단위
* 관계형 데이터베이스와 NoSQL의 차이
  * 관계형 데이터베이스는 엄격한 스키마 아래 행과 열로 구성된 테이블들의 관계로 데이터를 저장하는 데이터베이스이고 NoSQL은 스키마와 관계 없이 데이터를 저장하는 데이터베이스
  * 관계형 데이터베이스는 `속성(열)에 맞는 각각형 자료형에 따라` 데이터를 삽입해야하지만 NoSQL은 `key-value 구조`의 유연한 데이터 삽입 구조를 갖음

### Datastructure
* 배열과 링크드 리스트 비교
  * 배열은 순차적으로 데이터를 저장하는 자료구조로 메모리 상에 연속적으로 할당한 자료구조이고 링크드 리스트는 따로 할당하고 이은 자료구조
  * 배열은 순서를 알고 있다면 탐색에서 O(1) 삽입 삭제에서 O(N)
  * 링크드 리스트는 탐색에서 O(N) 순서를 알고 있다면 삽입 삭제에서 O(N)
* Binary Search Tree의 최악의 시간복잡도와 최악의 시간복잡도를 유발하는 케이스
  * 밸런싱이 된 BST는 O(logN)이지만 밸런싱이 되지 않지 않고 한쪽으로만 삽입된 경우 O(N)
* 해쉬테이블
  * 배열과 리스트의 장점을 합친 자료구조로 key 값을 통해 해시 주소를 알아내어 탐색에 있어 O(1)을 보장하는 자료구조

### Algorithm
* Fibonacci 공식을 재귀적인 방법과 동적 계획법을 이용했을 때 각각의 차이
  * 재귀적인 방법인 경우 재귀 호출 시에 중복되는 연산이 계속 수행되지만 동적 계획법의 경우 이전 값을 메모리제이션하기 때문에 중복 연산이 수행되지 않음
* DFS와 BFS
  * DFS는 스택이나 재귀호출로 구현할 수 있는 탐색 방법으로 노드에서 방문할 수 있는 노드를 끝까지 탐색하는 것을 반복하는 방식
  * BFS는 큐를 통해서 구현할 수 있는 탐색 방법으로 노드에서 방문할 수 있는 노드를 순서대로 탐색하는 것을 반복하는 방식


### Etc
* 클래스와 인스턴스의 차이
  * 클래스는 객체를 만들기 위한 템플릿, 객체는 클래스라는 템플릿을 토대로 메모리에 할당한 실체
* 스크립트 언어와 컴파일 언어의 차이
  * 컴파일 언어는 컴파일러를 통해 사전에 컴파일 되어 기계어 상태로 실행되고 스크립트 언어는 컴파일 단계 없이 인터프리터에 의해 실행 단계해서 한 줄씩 기계어로 번역하여 실행
  * 일반적으로 컴파일 언어가 스크립트 언어에 비해 빠르고 안정적임
* 동기식과 비동기식의 차이
  * 동기식은 요청에 대한 응답을 기다린 후 응답이 오면 실행하는 방식이고 비동기식은 요청에 대한 응답을 기다리지 않고 실행하는 방식
  * 동기식은 구성이 단순하나 멀티태스킹이 불가능하고 비동기식은 멀티태스킹이 가능하나 요청량이 많아질 경우 부하 컨트롤과 데이터의 일관성 유지 등 추가적인 처리가 필요
* 블락킹과 비동기의 차이
  * 블락킹과 비동기 모두 응답을 기다리지 않는 공통점이 있지만, 재실행 시점이 비동기는 요청에 대한 응답이라는 관점이고 블락킹은 함수 호출의 리턴이라는 관점에서 다름
* RESTful API
  * REST는 HTTP기반으로 필요한 자원에 접근하는 방식을 정해놓은 아키텍쳐로 RESTful API는 REST 기반의 규칙들을 지켜서 설계된 API
  * 설계 원칙1. `/`를 계층관계를 나타내는데 사용하되 마지막 문자에 `/`를 포함하지 않음
  * 설계 원칙2. 자원에 대한 정보는 명사로 표현하고 자원에 대한 행위는 HTTP 메소드로 표현
  * 설계 원칙3. 소문자와 `-`를 사용
* Redis와 MongoDB
  * Redis는 No SQL 방식을 사용하는 인메모리 데이터베이스로 `Key-Value` 형식으로 데이터를 저장하며 주로 캐쉬로 사용
  * MongoDB는 NO SQL 방식을 사용하는 데이터베이스로 JSON같은 구조의 `Document` 형식으로 데이터를 저장
* 디자인 패턴
  * 소프트웨어 코드 작성 시에 생기는 공통적인 문제를 해결하는데 도움이되는 코드 패턴
* 디자인 패턴 중 싱글톤 패턴
  * 전체 프로그램에서 단 1개의 객체를 생생하고 공유하는 코드 패턴
* 디자인 패턴 중 MVC 패턴
  * 

### Python
* Generator와 사용 시의 장점
  * Iterator를 생성해주는 루틴으로 `yield` 키워드를 통해서 만드는데, Generator는 한번에 모든 데이터를 메모리에 적재할 필요가 없어서 메모리 효율이 높고 계산 결과가 필요할 때 수행되므로 수행 시간을 꼭 필요한 시간까지 늦츨 수 있음
* Decorator와 사용 시의 장점
  * 기존의 코드에 여러 가지 기능을 추가하는 파이썬 구문으로 데코레이터를 함수나 클래스로 정의하고 수행하고자 하는 함수에 `@` 키워드를 통해서 삽입하여 실행시켜 생산성을 극대화할 수 있음
* Python Garbage Collection 동작 방식
  * 각각의 객체마다 `reference count`를 갖고 있고 몇 곳에서 객체를 참조하는지를 나타내는데 인터프리터가 계속 이를 확인하다가 이 count가 0이 되는 경우 그 객체를 삭제
*  GIL과 GIL을 보완하는 방법
  * 파이썬은 하나의 스레드만이 인터프리터의 제어권을 가질 수 있는 개념인 GIL(Global Interpreter Lock)은 멀티 코어 환경에서도 어느 시점에서나 1개의 스레드만 실행될 수 있기 때문에 `threading`이 아닌 `multiprocessing` 모듈을 통해 스레드 단위가 아닌 프로세스 별로 인터프리터 락을 잡아 보완해야함


### Django



### Java
* JVM과 Java 프로그램 실행 과정
  * JVM은 Java Virtual Machine의 약자로 자바 프로그램을 실행하는 역할을 하고 프로그램이 시작되면 컴파일러를 통해 바이트 코드로 변환하고 변환된 파일을 JVM에 로딩하여 실행
* Java에서 Garbage Collection이 필요한 이유에 대해서 설명
  * 자바는 메모리를 명시적으로 해제하지 않기 때문에 GC를 통해서 필요없는 객체를 지우는 작업을 수행
* JVM 메모리 영역 구조
  * 크게 `메소드 영역, JVM 스택, JVM 힙`으로 나뉘며 JVM 힙은 `Young Generation, Old Generation, Permanent Generation`으로 나뉘고 Young Generation은 `Eden, Survivor0, Survivor1`으로 나뉨
* Java Garbage Collection 동작 방식
  * 새롭게 생성된 객체는 Young의 Eden 영역으로 들어가게 되고 Eden 영역이 다 차면 Minor GC가 발생하여 참조 횟수에 따라 증가하는 `age bit`를 보고 불필요한 객체를 삭제하고 생존한 객체는 S0으로 이동
  * Minor GC가 발생할 때마다 각각 Young 영역의 객체들은 삭제와 이동을 하게되는데 (Eden -> S0 / S0 -> S1)
  * S1이 가득 차면 필요한 객체는 OLD 영역으로 이동하고 OLD 영역이 가득차면 Major GC를 통해서 값을 삭제
  * GC가 실행될 때마다 `STOP THE WORLD`가 발생하여 프로그램이 중지
* Overriding과 Overloading
  * 오버라이딩은 부모 클래스에 존재하는 메서드를 하위 클래스에서 재정의하는 것이고 오버로딩은 같은 메서드 이름을 갖게 하지만 시그니처가 다르게 정의하는 것
* 추상 클래스와 인터페이스
  * 추상 클래스는 반드시 구현해야하는 추상 메소드를 1개 이상 갖고 있는 클래스이고 인터페이스는 추상 메소드만 갖고 있는 개념으로 추상 클래스는 1번만 상속받을 수 있지만 인터페이스는 여러번 상속 가능

### Spring

