### Database
* DB를 사용하는 이유
  * 파일 시스템이 OS마다 다를 수 있기 때문에 OS에 종속적인 파일 시스템을 이용하는 것은 프로그램의 확장성을 해침
  * DB는 `원자적 갱신`, `동시성 제어`, `데이터 보호`, `백업 및 회복` 등의 여러 데이터 관리 기능을 두어 데이터 관리를 편하게 하기 때문에 파일 시스템을 활용하여 OS를 만듦
* 테이블
  * 행과 열로 이루어진 데이터의 집합
* 도메인
  * 데이터베이스 필드에 채워질 수 있는 값들의 집합
* 행
  * 테이블을 구성하는 데이터 셋으로 `튜플`이나 `레코드`라고 불림
* 열
  * 테이블을 구성하는 데이터 셋으로 `속성`이라고 불림
* 뷰
  * 특정 사용자로부터 특정 속성을 `숨기는` 기능으로 뷰를 정의하여 그 뷰를 테이블처럼 사용하게 하여 특정 속성을 숨김
  * 메모리에 물리적으로 존재하지 않는 가상 테이블
* 스키마와 테이블(릴레이션)의 차이
  * `스키마는 테이블(릴레이션)의 이름과 속성들의 나열`로 테이블에서의 첫 행 헤더이고 `테이블은 행과 열로 구성된 전체를 의미`
* 후보 키
  * 릴레이션을 구성하는 속성들 중에서 Tuple을 `유일하게 식별`할 수 있는 속성들의 부분 집합
* 주 키
  * 후보 키 중에서 선택한 Main Key
* 외래 키
  * 한 테이블의 키 중에서 다른 테이블의 튜플을 식별할 수 있는 키
  * 참조되는 릴레이션의 `주 키`와 대응되어 릴레이션 간에 `참조 관계`를 표현하는 키
  * 사용 이유: 테이블을 연결, 중복 방지
    * 예시: 물건 구매시 같은 사람이 여러 물건을 구매하면 사람에 대한 데이터가 중복 -> 사람과 물건 구매로 테이블을 분리해 중복 제거
* 트랜잭션
  * 데이터베이스의 상태를 변화시킬 때 한번에 수행되어야하는 하나의 `원자적인 작업의 단위`
  * Lock과 유사한 기능을 하지만 Lock은 동일한 자원을 요청할 경우 한 시점에는 하나의 커넥션만 변경하는데에 반해 트랜잭션은 논리적인 작업의 쿼리의 개수와 관계없이 논리적인 작업 셋 자체가 100% 적용되거나 아무것도 적용되지 않아야 함을 보장
* ACID
  * 데이터의 유효성을 보장하기 위한 트랜잭션의 특징
  * `Atomicity(원자성)`: `모든 작업이 반영되거나 모두 롤백되는 특성`입니다.
  * `Consistency(일관성)`: 데이터는 `미리 정의된 규칙에서만 수정이 가능한 특성`을 의미합니다.
  * `Isolation(고립성)`: A와 B 두개의 트랜젝션이 실행되고 있을 때, A의 작업들이 B에게 보여지는 정도를 의미합니다.
  * `Durability(영구성)`: 한번 반영(커밋)된 트랜젝션의 내용은 `영원히 적용`되는 특성을 의미합니다.
* 무결성 제약조건
  * 개체 무결성: 주키는 null, 중복 값을 가질 수 없음
  * 참조 무결성: 외래키는 null이거나 참조 릴레이션의 기본키 값과 동일해야 함
* 조인
  * 두 개 이상의 테이블이나 데이터베이스를 연결하여 데이터를 검색하는 방법으로 적어도 하나의 칼럼을 서로 공유하고 있어야 하므로 이를 이용하여 데이터 검색에 활용
* 시퀀스(오라클)
  * 기본키와 같은 유일한 숫자를 자동으로 생성하는 것
  * 캐쉬에 있어 속도 빠름
* 트리거
  * 자동으로 실행되게 정의한 프로시저
  * DML(INSERT, UPDATE, DELETE)에 의한 데이터 상태관리 자동화
  * 데이터 무결성 강화, 업무 처리 자동화
* SQL
  * DML: 데이터를 조작
    |명령어|설명|
    |:---:|:---|
    |SELECT|DB의 데이터 조회 및 검색|
    |INSERT|데이터 삽입|
    |UPDATE|데이터 수정|
    |DELETE|데이터 삭제|
  * DDL: 데이터(구조, 객체)를 정의
    |명령어|설명|
    |:---:|:---|
    |CREATE|DB의 테이블 생성|
    |DROP|테이블 삭제|
    |TRUNCATE|테이블의 데이터 삭제, 테이블 초기화|
    |ALTER|테이블 수정|
    * DROP과 TRUNCATE의 차이
  * DCL: 데이터 제어
    |명령어|설명|
    |:---:|:---|
    |GRANT|객체에 대한 권한 부여|
    |REVOKE|객체에 대한 권한 회수|
    |COMMIT|트랜잭션의 결과 반영|
    |ROLLBACK|트랜잭션 취소 및 원상 복구|
  * Commit과 Rollback
    * Rollback: 트랜잭션의 실행을 취소하였음을 알리는 연산자로 `트랜잭션이 수행한 결과를 원래의 상태로 원상 복귀시키는 연산`
* SQL Injection
  * 해커에 의해 조작된 SQL 쿼리문이 데이터베이스에 그대로 전달되어 비정상적인 명령을 실행시키는 공격 기법
  * view를 활용하여 접근하는 에러를 볼 수 없게 하고 검증 로직을 추가하여 방어해야함
* 힌트(Hint)
  * SQL을 튜닝하기 위한 지시 구문, 개발자가 직접 최적의 실행 계획을 제공하는 것
* Index를 사용하는 이유와 장점 및 단점
  * 인덱스는 추가적인 쓰기와 저장 공간 사용을 통해 데이터베이스의 `검색 속도 향상`을 위해 사용하는 자료구조
  * 테이블 내의 `칼럼의 값(Key)`과 해당 `Key의 레코드가 저장된 주소`를 `키와 값의 쌍으로 정의`
  * 인덱스를 사용하면 검색이 빨리지지만 테이블의 데이터가 추가, 삭제, 수정이 자주되는 경우 인덱스도 변경해야 하여 성능이 오히려 저하될 수 있음
* Index 자료구조
  * B 트리
    ![tree](https://user-images.githubusercontent.com/38900338/105454677-9bf88400-5cc5-11eb-993e-fb6f7b9675a1.png)
    * 이진 트리를 확장해서, 더 많은 수의 자식을 가질 수 있게 일반화 시킨 자료구조
    * 균형 트리: 루트 ~ 리프의 거리가 일정한 트리
    * Branch 노드: Key와 Data 저장
  * B+ 트리
    ![Bplustree](https://user-images.githubusercontent.com/38900338/105454222-d9104680-5cc4-11eb-96e9-31e46c0bf2aa.png)
    * B 트리를 확장해서, 데이터의 빠른 접근을 위한 인덱스 역할만 하는 비단말 노드(not Leaf)가 추가시킨 자료구조
    * B 트리보다 풀 스캔 빠름
    * Leaf 노드를 제외하면 데이터를 저장하지 않아 더 많은 Key를 저장할 수 있음 -> 트리의 높이가 낮아져 Cache Hit 향상 가능
    * Branch 노드: Key만 저장, Leaf 노드: Key와 Data 저장 + Linked List로 연결
  * 해시 테이블
    * 칼럼의 값으로 생성된 해시를 기반으로 인덱스 구현
    * O(1)로 매우 빠름
    * 인덱싱에선 등호 연산 때문에 해시 테이블을 사용하면 성능이 떨어짐
    * `>=, Between, like, order by` 등은 불가능하지만 `==, in, is null` 등에서의 성능은 좋음
* 정규화
  * 테이블의 속성들이 상호 종속적인 관계를 같는 특성을 이용하여 테이블을 `무손실 분해` 하는 과정
  * 데이터 `중복 최소화`, `이상 현상` 제거
  * 종류
    * 제 1 정규형: 모든 속성이 원자 값
    * 제 2 정규형: 완전 함수 종속
    * 제 3 정규형: 비이행적 종속(직접 종속)
    * BCNF: 함수 종속성 X->Y일 때, 모든 결정자 X가 후보키
* DB 클러스터링과 리플리케이션의 차이
  ||DB 클러스터링|리플리케이션|
  |:---:|:----------:|:---------:|
  |대상|DB 서버를 다중화|DB 서버와 데이터를 같이 다중화|
  |구조|수평적 구조<br>(Fail Over)|수직적 구조<br>(Master-Slave)|
  |방식|동기 방식으로 동기화|비동기 방식으로 동기화|
  |종류|Active - Active, Active - Standby|단순 백업, 부하 분산|
  |장점|일관성,<br>1개의 서버가 고장나도 시스템은 계속 사용 가능|시간 지연 거의 없음|
  |단점|동기화 시간 소요|일관성 없음,<br>Master 오류시 복구 어려움|
  |구조|![clustering](https://user-images.githubusercontent.com/38900338/105463364-4b882300-5cd3-11eb-9837-195b872852e2.JPG)|![replication](https://user-images.githubusercontent.com/38900338/105463420-5f338980-5cd3-11eb-8ea4-fe1bdc962385.JPG)|
* 커넥션 풀
  * 사용자의 요청에 따라 Connection 을 생성하다 보면 많은 수의 연결이 발생했을 때 서버에 과부하가 걸리게 되므로 이러한 상황을 방지하기 위해 `미리 일정 수의 Connection을 만들어 pool에 담아 뒀다가 사용자의 요청이 발생하면 연결을 해주고 연결 종료 시 pool에 다시 반환하여 보관하는 것`

* 관계형 데이터베이스(SQL)와 비관계형 데이터베이스(NoSQL)의 차이
  |관계형 데이터베이스|비관계형 데이터베이스|
  |:----------:|:---------:|
  |엄격한 스키마 아래 행과 열로 구성된 테이블들의 관계로 데이터를 저장|스키마가 없거나 느슨한 스키마로 데이터를 저장|
  |`속성(열)에 맞는 각각형 자료형에 따라` 데이터를 삽입|`key-value 구조`이거나 `Document 구조`의 유연한 데이터 삽입 구조를 갖음|
  |관계를 맺고 있는 데이터가 자주 변경되거나 테이블 안에서 읽어올 데이터가 불분명한 경우 또는 명확한 스키마가 있는 경우|데이터 구조를 알 수 없거나 테이블 안에서 읽어올 데이터가 분명한 경우 또는 변경/확장이 쉡게 되어야하는 경우|
  |데이터의 정렬, 탐색, 분류가 빠름<br>데이터 무결성 보장|대용량 데이터 처리에 효율적<br>관계형DB보다 쓰기와 읽기 성능이 좋음<br>유연하고 확장성 좋음|
  |기존의 스키마 수정 어려움, 빅데이터 처리에 비효율적|크기가 큰 Document에서는 성능 저하|
  |`Oracle`, `MySQL`|키-값: `Redis`<br>문서형(JSON): `MongoDB`|
* PostgresSQL과 ElasticSearch의 차이점
  * PostgresSQL은 관계형 데이터베이스이고 ElasticSearch는 검색 및 분석엔진으로 다르고 ES는 데이터 모델을 JSON으로 하고 있어 NoSQL처럼 사용할 수 있음
* Redis와 MongoDB
  * Redis는 No SQL 방식을 사용하는 인메모리 데이터베이스로 `Key-Value` 형식으로 데이터를 저장하며 주로 캐쉬로 사용
  * MongoDB는 NO SQL 방식을 사용하는 데이터베이스로 JSON같은 구조의 `Document` 형식으로 데이터를 저장하고 문서에 대한 ID를 키로 표현
* Redis의 데이터 휘발을 막기 위한 방법
  * `snapshot` 기능을 통해 디스크에 백업하거나 AOF 기능을 통해 `명령 쿼리를 저장`해두고 서버가 셧다운 되면 재실행