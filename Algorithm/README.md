### Algorithm
* 빅오 표기법
  * Big O 표기법는 컴퓨터 공학에서 알고리즘의 시간복잡도(실행시간)이나, 공간 복잡도(사용 메모리)에 대한 최악의 경우를 표현하는 표기 방법
* 정렬 알고리즘에서 `stable` 하다는 것의 의미
  * 정렬 기준으로 봤을 때 값이 `동일한 Element가 있어도 정렬 전의 순서와 정렬 후의 순서가 동일함을 보장`하는 것
* 정렬 알고리즘의 가짓수가 많은 이유
  * `공간 복잡도`에 따라 사용해야할 알고리즘이 다름 -> Merge Sort는 공간 복잡도는 Selection Sort와 Insertion Sort에 비해 큼
  * `안정 정렬`이냐 `불안정 정렬`이냐에 따라 사용해야할 때가 다름
* Selection Sort
  * 선택 정렬은 가장 작은 값을 가지는 데이터를 찾아서 가장 작은 값을 앞에서부터 채워 나가면서 정렬하는 방식으로 동작하는 O(n^2) `불안정 정렬 알고리즘`으로 1번의 순환마다 맨 앞의 값이 고정
* Bubble Sort
  * 버블 정렬이란 처음부터 끝까지 현재 자신과 자신의 다음 데이터를 비교해가면서 큰 값을 맨 뒤로 보내는 방식으로 동작하는 O(n^2) `안정 정렬 알고리즘`으로 1번의 순환마다 맨 뒤의 값이 고정
* Merge Sort
  * 병합 정렬은 배열을 반으로 쪼개 가면서 하나의 원소를 가진 배열로 만든 이후에 쪼개진 각 배열을 정렬하면서 병합하여 최종 정렬된 배열을 완성하는 O(NlonN) `안정 정렬 알고리즘`
* Heap Sort
  * 완전 이진 트리를 기본으로 하는 힙에 데이터를 삽입하고 꺼내서 힙을 통해 정렬하는 O(NlogN) `불안정 정렬 알고리즘`
* Quick Sort
  * 분할 정복 알고리즘으로 `파티셔닝` 아이디어를 재귀적으로 활용
  * `파티셔닝`이란 pivot 원소를 기준으로 왼쪽은 pivot보다 작은 원소들로 모으고 오른쪽은 pivot보다 큰 원소로 모으는 것을 의미하는데 pivot을 기준으로 파티셔닝이 완료되면 pivot을 고정하고 재귀호출 하여 구현하는 O(NlonN) `불안정 정렬 알고리즘`
  * Quick Sort가 통상적으로 가장 빠른 정렬을 지원하지만 `Worst Case에서 O(n^2)`이므로 Tim Sort나 Heap Sort를 사용하기도 함
* 이분 탐색
  * 이분 탐색은 `이미 정렬되어 있는 자료구조`에서 특정 값을 탐색할 때 탐색 범위를 반으로 쪼개서 값을 찾아가는 알고리즘
  * O(logN)으로 순차 탐색보다 빠르지만 탐색을 위해 정렬을 하면 순차 탐색보다 더 높은 시간복잡도를 갖게 됨
* Fibonacci 공식을 재귀적인 방법과 동적 계획법을 이용했을 때 각각의 차이
  * 재귀적인 방법인 경우 재귀 호출 시에 중복되는 연산이 계속 수행되지만 동적 계획법의 경우 이전 값을 `메모리제이션`하기 때문에 중복 연산이 수행되지 않음
* DFS와 BFS
  * DFS는 `스택이나 재귀호출`로 구현할 수 있는 탐색 방법으로 한 정점으로부터 연결되어 있는 한 정점으로만 나아가는 방식
  * BFS는 `큐`를 통해서 구현할 수 있는 탐색 방법으로 한 정점으로부터 연결되어 있는 모든 정점을 나아가며 탐색하는 방식으로 BFS로 구한 경로는 최단 경로라는 장점이 존재
* 재귀호출을 이용할 때의 문제점
  * 스택의 범위를 초과할 수 있음